package zzc.chun.zju.Learning.sort;

import java.util.Arrays;

public class BubbleSort {

	public static void main(String[] args) {

		int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 5, 4, 62, 
				99, 98, 54, 56, 17, 18, 23, 34, 15, 35, 25, 53, 51};
		sort(a);
		System.out.println(Arrays.toString(a));
	}
	
	private static void sort(int[] a){
		int tmp;
		for(int i = 0; i < a.length - 1; i++){
			for(int j = 0; j < a.length - i - 1; j++){
				
				
				if(a[j] > a[j + 1]){
					tmp = a[j];
					a[j] = a[j + 1];
					a[j + 1] = tmp;
				}
				//System.out.println(i + "  " + j + "   " + Arrays.toString(a));
			}
		}
	}
}

/*
 冒泡排序算法流程：
 1. 比较相邻的两个元素，如果第一个比第二个大，就交换他们两个；
 2. 对每一对相邻的匀速做同样的工作，从开始第一对到结尾最后一对。
 	执行完一次该操作，最大数就到了末尾
 3. 针对所有的元素重复以上的步骤，除了最后一个。
 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一个数字需要比较。
 
以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：
第一次外循环
( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 > 1 交换位置
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 > 4 交换位置
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 > 2 交换位置
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 < 8 位置不变
第二次外循环（除开最后一个元素8，对剩余的序列）
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 < 4 位置不变
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 > 2 交换位置
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 < 5 位置不变
第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
第四次外循环（最后一次）
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

*/
